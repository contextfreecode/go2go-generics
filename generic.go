// Code generated by go2go; DO NOT EDIT.


//line generic.go2:1
package main

//line generic.go2:1
import (
//line generic.go2:1
 "fmt"
//line generic.go2:1
 "math"
//line generic.go2:1
)

//line generic.go2:10
type AnyVec interface {
	At(i int) interface{}
	Size() int
}

type AnyPoint2 struct {
	X float32
	Y float32
}

func (point AnyPoint2) At(i int) interface{} {
	if i == 0 {
		return point.X
	}
	return point.Y
}

func (point AnyPoint2) Size() int {
	return 2
}

func NormAny(vec AnyVec) float64 {
	if vec.Size() == 0 {
		return 0
	}
	var result float64 = 0
	for i := 0; i < vec.Size(); i++ {
		var x float64
		switch val := vec.At(i).(type) {
		case float32:
			x = float64(val)
		case float64:
			x = val
		}
		result += x * x
	}
	return math.Sqrt(result)
}

//line generic.go2:79
type Point2 struct {
	X float32
	Y float32
}

func (point Point2) At(i int) float32 {
	if i == 0 {
		return point.X
	}
	return point.Y
}

func (point Point2) Size() int {
	return 2
}

//line generic.go2:121
func NormNdIVec(a ...float64) float64 {
	return instantiate୦୦NormIVec୦float64(instantiate୦୦SliceVec୦float64{Slice: a})
}

func NormNd(a ...float64) float64 {
	return instantiate୦୦Norm୦float64୦main୮aSliceVec୮8float64୮9(instantiate୦୦SliceVec୦float64{Slice: a})
}

func Norm2fIVec(x, y float32) float32 {
	return instantiate୦୦NormIVec୦float32(Point2{X: x, Y: y})
}

func Norm2f(x, y float32) float32 {
	return instantiate୦୦Norm୦float32୦main୮aPoint2(Point2{X: x, Y: y})
}

func Norm2fSimple(x, y float32) float32 {
	return float32(math.Sqrt(float64(x*x + y*y)))
}

func Norm2fAny(x, y float32) float32 {
	return float32(NormAny(AnyPoint2{X: x, Y: y}))
}

//line generic.go2:147
func main() {
	fmt.Println(NormNdIVec(1, 2, 3))
	fmt.Println(NormNd(1, 2, 3))
	fmt.Println(Norm2fIVec(3, 4))
	fmt.Println(Norm2f(3, 4))
	fmt.Println(Norm2fSimple(3, 4))
	fmt.Println(Norm2fAny(3, 4))
}

//line generic.go2:154
type instantiate୦୦SliceVec୦float64 struct {
//line generic.go2:66
 Slice []float64
}

func (vec instantiate୦୦SliceVec୦float64,) At(i int) float64 {
	return vec.Slice[i]
}

func (vec instantiate୦୦SliceVec୦float64,) Size() int {
	return len(vec.Slice)
}

//line generic.go2:97
func instantiate୦୦NormIVec୦float64(vec instantiate୦୦Vec୦float64,) float64 {
	if vec.Size() == 0 {
		return 0
	}
	var result float64 = 0
	for i := 0; i < vec.Size(); i++ {
		result += vec.At(i) * vec.At(i)
	}
	return float64(math.Sqrt(float64(result)))
}

func instantiate୦୦Norm୦float64୦main୮aSliceVec୮8float64୮9(vec instantiate୦୦SliceVec୦float64,) float64 {
	if vec.Size() == 0 {
		return 0
	}
	var result float64 = 0
	for i := 0; i < vec.Size(); i++ {
		result += vec.At(i) * vec.At(i)
	}
	return float64(math.Sqrt(float64(result)))
}
//line generic.go2:97
func instantiate୦୦NormIVec୦float32(vec instantiate୦୦Vec୦float32,) float32 {
	if vec.Size() == 0 {
		return 0
	}
	var result float32 = 0
	for i := 0; i < vec.Size(); i++ {
		result += vec.At(i) * vec.At(i)
	}
	return float32(math.Sqrt(float64(result)))
}

func instantiate୦୦Norm୦float32୦main୮aPoint2(vec Point2) float32 {
	if vec.Size() == 0 {
		return 0
	}
	var result float32 = 0
	for i := 0; i < vec.Size(); i++ {
		result += vec.At(i) * vec.At(i)
	}
	return float32(math.Sqrt(float64(result)))
}

//line generic.go2:117
type instantiate୦୦Vec୦float64 interface {
//line generic.go2:59
 At(i int) float64
			Size() int
}
//line generic.go2:61
type instantiate୦୦Vec୦float32 interface {
//line generic.go2:59
 At(i int) float32
			Size() int
}
//line generic.go2:61
type Importable୦ int

//line generic.go2:61
var _ = fmt.Errorf
//line generic.go2:61
var _ = math.Abs
